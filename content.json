{"pages":[{"title":"","text":"关于我 1、 拒绝敷衍，坚持原创 2、我也是一员努力打拼的码农，在奋斗的路上努力前行。 3、笔名【Java Keep Studying】,本名倪勇,可称呼阿勇或者勇哥均可。 4、 博客作为本人的平时工作学习的产出地方，以此来激励自己学习。 5、该博客属于个人，所有观点也是我个人的观点，跟任何组织机构无关。 6、我是武汉某所专科学校毕业的学渣，专业：计算机应用技术，为了维护学校的尊严，校名就不透露了。后来经过短暂的培训成为了一名正儿八经的程序员。 7、写博文的目的是想沉淀自己的技术，表达自己的所思所想。同时希望能够认识更多的互联网朋友，跟大家一起交流对互联网对科技的认知，聊聊生活上的喜悦和烦恼，分享职场晋升或者面试的经验或者教训 8、在这里，我必须要感谢那些点赞、评论、转发的朋友们，你们的参与是我在写作道路上的最强动力；我也必须要感谢那些赞赏的朋友们，对于原创作者来说，这是最真诚的心意，无关金额的多少。 关注微信公众号 公众号:Java Keep Studying image-20200412115340027 分享内容 专注于JavaSE、数据结构和算法、JavaEE、各种框架、JavaWeb、Mysql、各种实战项目的学习及各种Java学习资源和面试题的分享，希望大家能在技术上得到一定的提升 微信交流群 技术交流为主,开发学习工作中遇到问题可以在微信群交流。欢迎有需要的朋友加群 群规: 群内禁止任何形式的广告，推广，小程序链接等，仅限技术、经验、生活感悟、个人成长等交流。一经发现，立即抱出群外。 联系我 有什么事加微信联系吧，欢迎反馈问题，欢迎交流分享，欢迎互推，欢迎转载文章 个人微信 以下是我微信号的二维码，有兴趣的话，可以加个微信，交个朋友哈哈~ 注:备注来意,具体事项理由！（格式：姓名+目的），否则不予通过，谢谢理解和配合！ 比如：李四 + 转载文章 其他站点博客 1、hexo博客 https://mysuperstart.gitee.io/ 2、CSDN博客 https://blog.csdn.net/qq_41473905","link":"/about/index.html"}],"posts":[{"title":"自定义数据库连接池&amp;常用第三方数据连接池","text":"什么是数据库连接池？答：就是一个容器，容器里面有很多连接对象 为什么要有数据库连接池？原生JDBC的坏处每次用完链接后都要释放，造成了内存空间的浪费 使用数据库连接池的好处每次用完链接后不是直接释放，而是将链接对象重新归还给了数据库连接池，从而实现了连接对象复用的效果,提高了性能 自定义数据库连接池步骤1、定义个类，实现DataSource接口 2、定义线程安全的成员变量List&lt;Connection&gt; list并初始化 1private static List&lt;Connection&gt; pool = Collections.synchronizedList(new ArrayList&lt;Connection&gt;()); 3、静态代码块，初始化连接数量 4、重写接口中getConnection()方法，获取连接 123456789if(pool.size()&gt;0){ Connection conn = pool.remove(0); // ........ // 使用自定义连接对象，对原有的链接对象进行包装，代码略.... // 使用动态代理的方式完成归还连接，代码略...... return conn;}else{ throw new RuntimeException(&quot;....&quot;);} 5、自定义int getSize()方法，返回数据库连接池中链接对象的数量 6、测试类中测试 归还连接方式一:包装/装饰者设计模式1、定义个类实现Connection接口 2、定义成员变量Connection、List&lt;Connection&gt; 3、通过有参构造初始化成员变量 4、重写接口中close()方法，实现归还连接 5、剩余的方法，调用原有的链接对象中的功能即可 6、在自定义数据库连接池类中，使用定义好的自定义连接对象，对原有的Connection对象进行包装 方式二:适配器设计模式1、定义个适配器类（抽象类），实现Connection接口 2、定义成员变量Connection 3、通过有参构造初始化成员变量 4、重写接口中除了close以外的方法 5、定义个类继承适配器类6、定义成员变量Connection、List&lt;Connection&gt; 7、带参构造对成员变量进行赋值 8，重写close方法,实现归还连接 9、在自定义数据库连接池类中，使用定义好的自定义连接对象，对原有的Connection对象进行包装 方式三:JDK动态代理概念在不改变目标类的代码的基础上，对目标类中的方法进行增强 组成代理对象：表示目标对象 被代理对象：内存中动态生成的一个对象 前提必须要有一个接口和实现类(目标类) 使用12345678910Proxy.newProxyInstance(ClassLoader,Class&lt;?&gt;[] interfaces,InvocationHandler)/*ClassLoader：代理对象和被代理必须实现相同的类加载器Class&lt;?&gt;[] interfaces ： 表示代理对象必须和被代理对象实现相同的接口InvocationHandler ： 表示代理规则，也就是要增强的功能 invoke(Object proxy,Method method,Obkecy[] args) 动态代理对象每次执行方法时都会经过该invoke方法 proxy ： 我们不需关心 method： 当前代理对象执行的是哪个方法，这个method就指代该成员方法对象 args : 代理对象执行方法时，传递的参数会封装到这个args数组中*/ 代码展示123456789101112131415161718192021222324252627282930public class Student implements StudentInter{ public void study(){ &quot;在家自学&quot;.sout; } public void eat(String name) { &quot;正在吃&quot;+name.sout; }}interface StudentInter{ void study(); void eat(String name);}class ProxyTest{ public static void main(String[] args){ // 创建Student对象 Student stu = new Student(); // 在内存中创建动态代理对象 StudentInter stuProxy = (StudentInter)Proxy.newProxyInstance(stu.getClass().getClassLoader(),new Class[]{StudentInter.class},(proxy,method,agr)-&gt;{ if(method.getName(&quot;study&quot;)){ &quot;在培训机构学习&quot;.sout return null; }else{ return method.invoke(stu,arg); } }); // 调用方法 stuProxy.eat(&quot;米饭&quot;); stuProxy.study(); } } 使用JDK动态代理实现归还连接的核心代码12345678910Connection targetConn = (Connection)Proxy.newProxyInstance(conn.getClass().getClassLoader(),new Class[]{Connection.class},(proxy,method,arg)-&gt;{ if(method.getName().equals(&quot;close&quot;)) { // 归还连接 pool.add(conn); return null; }else{ // 如果不是close方法，直接调用原有Connection连接对象的方法即可 return method.invoke(conn,arg); }}) 执行流程 常用第三方数据库连接池技术c3p0步骤1、导入jar包&amp;c3p0-config.xml||c3p0.properties文件、 c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 2、创建c3p0数据库连接池对象 ComboPooledDataSource(String configName)// 采用指定配置 ComboPooledDataSource() // 采用默认配置 3、获取链接对象 代码展示12345678910111213141516171819202122232425262728public class C3P0Test { public static void main(String[] args) { // 采用默认配置，创建C3P0数据库连接池对象 DataSource dataSource = new ComboPooledDataSource(); // 获取链接对象 Connection conn = dataSource.getConnection(); // 定义sql语句 String sql = &quot;select * from student&quot;; // 通过链接对象获取预编译语句执行者对象 PreparedStatement statement = conn.prepareStatement(sql); // 执行sql语句，返回结果集对象 ResultSet rs = statement.executeQuery(); // 处理结果集 while(rs.next()) { // 获取数据 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); // 打印 System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+age); } // 释放资源 rs.close(); statement.close(); // 归还连接 conn.close(); }} Druid(最常用)步骤1、导入jar包&amp;xxxxx.properties配置文件 druid-1.0.9.jar 2、加载配置文件（提示:prop.load(is)） 2、通过Druid数据库连接池工厂创建连接池对象 1DruidDataSourceFactory.createDataSource(Map|Properties); 3、获取链接 代码展示1234567891011121314151617181920212223242526272829303132public class DruidTest { public static void main(String[] args) throws Exception { // 通过类加载器将配置文件加载进内存，返回一个字节输入流对象 InputStream is = DruidTest.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); // 创建Properties集合 Properties prop = new Properties(); // 将配置文件中的键值对信息加载到Properties集合中 prop.load(is); // 通过Druid数据库连接池工厂类的静态方法createDataSource(Map|Properties)来创建数据库连接池对象 DataSource ds = DruidDataSourceFactory.createDatSource(prop); // 获取链接对象 Connection conn = prop.getConnection(); // 定义sql语句 String sql = &quot;select * from student&quot;; // 通过链接对象获取预编译语句执行者对象 PreparedStatement ps = conn.prepareStatement(sql); // 执行sql语句,返回结果集对象 ResultSet set = ps.executeQuery(); // 处理结果集 while(set.next()) { int id = set.getInt(&quot;id&quot;); String name = set.getString(&quot;name&quot;); int age = set.getInt(&quot;age&quot;); System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+age) } //释放资源 rs.close(); ps.close(); // 归还连接 conn.close(); }} 拓展：在该jar包中有个工具类JdbcUtils c3p0&amp;Druid区别？ 区别 描述 导入的jar包数量 c3p0要导入两个jar包，druid只需导入一个。 配置文件所在位置及文件名 c3p0配置文件名只能是c3p0-config.xml或者c3p0.properties。druid配置文件名无硬性要求。比如:任意文件名.properties文件都可以。不管是druid还是c3p0，配置文件都必须放在src目录下 是否自动加载配置文件 c3p0在创建数据库连接池对象时会自动加载配置文件,druid不会自动加载配置文件，需要手动加载，通过静态代码块可以完成加载 close方法 不管是druid还是c3p0，close方法都会自动归还链接 获取数据库连接池对象所采用Api c3p0使用的是ComboPooledDatSource([String configname])构造来完成数据库连接池的初始化 ,Druid使用的是DruidDataSourceFactory.createDataSource(Map|Properties)来实现数据库连接池的初始化 数据库连接池工具类步骤1、私有构造 2、声明静态数据源变量DataSource 2、静态代码块(读取配置文件、初始化数据源DataSource) 3、获取链接对象 4、释放链接 5、获取数据库连接池对象DataSource 代码展示(以Druid数据库连接池工具类为例)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class DruidDataSourceUtils{ // 私有构造 private DruidDataSourceUtils(){} // 声明数据源变量 private static DataSource dataSource; // 静态代码块 static{ try{ // 将配置文件加载进内存，返回字节输入流对象 InputStream is = DruidDataSourceUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); // 创建Properties集合对象，用来装载配置文件信息 Properties prop = new Properties(); // 将配置文件中的内容加载到Properties集合中 prop.load(is); // 通过Druid数据库连接池工厂的静态方法createDataSource(Map|Properties)创建数据源对象 dataSource = DruidDateSourceFactory.createDataSource(prop); }catch(Exception ex){ ex.printStackTrace(); } } // 获取链接对象 public static Connection getConnection(){ Collection conn = null; try{ // 获取链接对象 conn = dataSource.getConnection(); }catch(Exception ex) { ex.printStackTrace(); } return conn; } // 获取数据库连接池对象 public static DataSource getDataSource(){ return dataSource; } // 释放资源 public static void close(ResultSet rs,Statement state,Connection conn) { if(rs != null) { try{ rs.close() }catch(Exception ex){ ex.printStackTrace(); } } // ....... } public static void close(Statement state,Connection conn) { if(state != null){ try{ state.close(); }catch(Exception ex){ ex.printStackTrace(); } } // ....... }}","link":"/2020/09/07/JDBC%E9%AB%98%E7%BA%A7/"},{"title":"JDBC:用Java语言操作Mysql数据库","text":"JDBC快速入门步骤0、导入jar包,mysql-connector-java-5.1.37-bin.jar 1、注册驱动 2、获取Connection连接对象 3、获取语句执行者对象 4、定义SQL语句 5、执行SQL语句 6、释放资源 代码展示123456789101112131415161718192021222324252627public class JdbcQuickStart { public static void main(String[] agrs) { // 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 获取链接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///db2&quot;,&quot;root&quot;,&quot;root&quot;); // 定义sql语句 String sql = &quot;select * from student&quot;; // 通过连接对象获取到预编译的语句执行者对象 PreparedStatement ps = conn.prepareStatement(sql); // 执行sql语句 Resultset rs = ps.executeQuery(); // 处理结果 while(rs.next()) { // 获取数据 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getDate(&quot;age&quot;); // 输出 System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+age); } // 释放资源，先开启后关闭 rs.close(); ps.close(); conn.close(); }} JDBC规范中相关API的功能DriverManager1、注册驱动 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 当Driver这个类被加载时，会自动注册驱动。 2、获取链接对象 1Connection conn = DriverManager.getConnection(String url,String username,String password); Connection1、管理事务 123conn.setAutoCommit(false); // 开启事务==手动提交conn.commit(); // 提交事务conn.rollback();// 回退/回滚事务 2、获取语句执行者对象 1234// 获取预编译的语句执行者对象，用于预编译sql语句（推荐） 能够防止sql注入PreparedStatement ps = conn.prepareStatement(String sql);// 获取普通的语句执行者对象（不推荐）Statement state = conn.createStatement(); 3、释放资源 12// 释放资源，先开启后关闭conn.close(); Statement1、执行SQL语句 1234567891011// 采用Statement // 执行DQL，返回结果集对象state.executeQuery(String sql);// 执行DML,返回受影响的行数state.executeUpdate(String sql);// ----------------------------// 采用PreparedStatement// 执行DQL,返回结果集对象ps.executeQuery();// 执行DML，返回受影响的行数ps.executeUpdate(); 2、释放资源 12state.close();ps.close(); ResultSet1、处理结果 12// 获取rs指向的这条数据，然后再把指针向下移动，下次判断再次比较rs指向的位置是否存在数据。rs.next() 2、获取数据 12rs.getXxx(int 列名索引 || String 列名);// Xxx 表示 字段类型 3、释放资源 1rs.close(); DbUtils工具类注：要用下面两个类必须先导入jar包。commons-dbutils-1.6.jar QueryRunner执行sql语句12345678910111213141516// 方式一:// 创建QuertRunner对象QueryRunner queryRunner = new QueryRunner();// 执行DQL类型 变量名 = queryRunner.query(Connection,String,new BeanHandler&lt;&gt;(类型.class)[,Object...parameters]);List&lt;类型&gt; 变量名 = queryRunner.query(Connection,String sql,new BeanListHandler&lt;&gt;(类型.class)[,Object...parameters]);// 执行DQLint 受影响行数 = queryRunner.update(Connection,String sql[,Object...parameters]); // 方式二:QueryRunner queryRunner = new QueryRunner(DataSource);// 执行DML，返回受影响的行数queryRunner.update(String sql[,Object...parameters]);// 执行DQL,返回具体的集合或者对象类型 变量名 = queryRunner.query(String,new BeanHandler&lt;&gt;(类型.class)[,Object...parameters]);List&lt;类型&gt; 变量名 = queryRunner.query(String sql,new BeanListHandler&lt;&gt;(类型.class)[,Object...parameters]); 说明:”[]”括起来的内容可有可无 Dbutils释放资源12DbUtils.close(Connection||Statement||ResultSet);DbUtils.closeQuietly(Connection||Statement||ResultSet); 自定义JDBC工具类1、src目录下创建jdbc.properties配置文件 12345# 驱动类driverClass=com.mysql.jdbc.Driverusername=rootpassword=rooturl=jdbc:mysql://localhost:3306/db1 2、编写工具类JDBCUtils 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class JDBCUtils{ // 1、私有构造 private JDBCUtils() {} // 2、声明配置变量 private static Connection connection; private static String username; private static String password; private static String url; private static String driverClass; // 3、编写静态代码块，读取配置文件，加载驱动 static { try{ // 将配置文件加载进内存，获取对应的字节输入流对象 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); // 创建Properties集合对象 Properties prop = new Properties(); // 将配置文件内容加载到Properties集合中 prop.load(in); // 通过键获取值 username = prop.getProperty(&quot;username&quot;); password = prop.getProperty(&quot;password&quot;); dirverClass = prop.getProperty(&quot;driverClass&quot;); url = prop.getProperty(&quot;url&quot;); // 注册驱动 Class.forName(diverClass); }catch(Exception ex) { ex.printStackTrace(); } } // 4、获取链接Connection对象 public static Connection getConnection() { try { connection = DriverManager.getConnection(url,username,password); }catch(Exception ex){ ex.printStackTrace(); } return connection; } /** * 释放资源 (DQL) * @param resultSet * @param statement * @param conn */ public static void close(ResultSet resultSet , Statement statement,Connection conn) { if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 释放资源 (DML) * @param statement * @param conn */ public static void close(Statement statement,Connection conn) { if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }} sql注入如何产生？使用普通语句执行者对象Statement执行sql语句时容易出现该问题。 核心: or 恒成立式子 ，比如 or 1 = 1，等价于查询所有。 12345678910111213// 获取普通的语句执行者对象Statement state = conn.createStatement();// 定义sql语句String sql = &quot;select * from user where username = zhangsan and password = 123 or 1 = 1&quot;;// 执行sql语句ResultSet set = state.executeQuery(sql);/* 描述: 即使这个zhangsan和123在数据表user中不存在，也会查出user表中的全部记录 坏处： 若前台用户输入的用户名正确，输入的密码是错误的，但是在密码后面加上了 or '1' = '1',此时，若后台采用的是statement来处理相关联的 sql语句时，会引发sql注入的问题。*/ 如何解决？答:使用PrepareStatement对象解决 1234567// 获取预编译语句执行者对象PreparedStatement ps = conn.prepareStatement(&quot;select * from user where username = ? and password = ?&quot;);// 给占位符赋值ps.setString(1,&quot;zhangsan&quot;);ps.setString(2,&quot;123&quot;);// 执行sql语句ResultSet set = ps.executeQuery(); JDBC事务操作1234567891011121314151617// 获取链接对象Connection conn = JDBCUtils.getConnection();// 开启事务 == 手动提交conn.setAutoCommit(false);try{ /* 执行业务逻辑代码(比如：转账)，转入和转出。 代码略... 完成执行这个业务逻辑代码期间要用到的conn对象必须是同一个Connection对象 */ .... // 执行以上代码没有出现任何问题，就提交事务 conn.commit; }catch(Exception ex) { ex.printStackTrace(); // 回滚/回退事务 conn.rollback(); } 注意:必须使用的是同一个Connection连接对象，否则是实现不了事务的效果的","link":"/2020/09/04/JDBC/"},{"title":"Mybatis框架第一天","text":"什么是框架？框架就是一个半成品软件，框架很多东西都给我们实现了，我们只需遵守框架的规则进行学习 什么是ORM?ORM：对象关系映射 也就是让Java对象和关系型数据库产生关联。产生关联后，我们操作Java对象就像是在操作数据表 表与实体类的映射规则表名对应Java实体类 表中字段对应Java实体类中的成员变量 表中每条记录对应该类的每个对象 原生Jdbc的缺点 1、sql硬编码，不易维护 2、DQL需手动封装数据 3、DML需手动给占位符赋值 4、频繁开启&amp;释放链接 解决办法 4—&gt;使用数据库连接池，每次归还连接 2、3—&gt;使用反射&amp;内省技术完成 什么是Mybatis框架？基础Java一个ORM框架，底层封装了对Jdbc的操作 Idea上连接Mysql数据库 ​ Mybatis入门程序步骤： 0、导入jar包 0.1、mysql驱动jar包 0.2、mybatis核心jia包 若想进行测试导入单元测试的jar包也是可以的 1、创建数据表 2、创建实体类 3、编写Mybatis核心配置文件 4、编写Mybatis映射文件 5、测试 Mybatis相关apiResource：加载类加载路径下的配置文件 getResourceAsStream(“核心配置文件.xml”) SqlSessionFactoryBuilder:采用构建者模式构建SqlSessionFactory对象 builder(InputStream|Reader,[String 环境名称]) SqlSessionFactory:采用工厂模式构建SqlSession对象 openssion(boolean) true:表示自动提交 false表示手动提交 注意：增删改需要提交事务，手动/自动提交都可以 SqlSession：会话对象，就相当于Jdbc中的Connection连接对象 执行sql selectList(“namespace.id值”[,Object obj]) selectOne(“namespace.id值”[,Object obj]) update(“namespace.id值”,(,Object obj)) insert(“namespace.id值”[,Object obj]) delete(“namespace.id值”,[,Object obj]) 管理事务 commit() : 提交事务 rollback() ： 回滚事务 Mybatis映射文件的配置标签 select insert update delete 属性 namespace:名称空间，用来区分各个mybatis映射文件，防止冲突.该属性就相当于java中的包,java中的包是用来管理java类的，而namespace是用来管理这些mybatis映射文件的 比如： AMapper.xml中有个findAll，BMapper.xml中也有一个findAll，去执行这个findAll的时候，mybatis框架是不知道我们具体要执行哪个xml文件中的findAll的，只有使用了namespace属性进行区分mybatis框架才知道具体要执行哪个findAll. id:唯一标识。 paramerType:表示参数类型（可以省略不写） resultType:表示结果集类型。也就是select语句执行完后返回的结果会封装到你指定的这个resultType类型中，返回到调用这个sql语句的地方进行使用。只有select才有resultType. Mybatis核心配置文件配置数据库环境 环境多选一 配置映射 1234567&lt;mappers&gt; &lt;!-- url:网络中的路径 resource:最常用,指定项目中Mybatis映射文件所在的位置--&gt; &lt;mappers resource=&quot;com/UserMapper.xml&quot;&gt;&lt;/mappers&gt;&lt;/mappers&gt; 配置类型别名 配置前 resultType=”io.domian.Student” 配置后 resultType=”student” 坏处：打印日志中可能会出现乱码 配置日志 123&lt;settings&gt; &lt;setting&gt;&lt;/setting&gt;&lt;/settings&gt; 加载属性配置文件 1 需要注意标签出现的先后顺序，出现问题后光标悬停在跟标签上（推荐），会有提示。当然你查看mybatis的约束文件(不推荐)也是可以的. 如何实现Mybatis框架执行Sql语句的日志记录？（采用Log4j） 实现步骤： 1、导入jar包 2、src下导入配置文件 3、核心配置文件中配置&lt;settings&gt; Mybatis取值方式 1、ognl表达式 2、EL表达式 ognl表达式 好处：防止sql注入漏洞。预编译sql时采用的占位符?,然后在将传进来的值依次给占位符赋值 缺点：模糊查询 ,’%#{username}%’不可行，也可以这样selectList(“…..”,”%huang%”) ,然后 like #{username} El表达式 好处：模糊查询 ，‘%${username}%’可行 缺点：引发sql注入漏洞。直接将传进来的值拼接到sql上了 单值参数，名称任意 比如:select * from student where id = #{xxxx} 多值参数，名称不可任意 比如:insert into student values(#{id},#{name},#{age}) #{内容}：内容一般都代表唯一的键或者属性名,比如map集合的键 假设传进来的是一个map集合(insert(“….”,map)) #{gender}:就表示根据这个gender键获取对应的值 假设传进来的是一个Student对象(insert(“…”,student)) #{id}：就相当于调用了该对象的getId()方法获取了该对象的值 获取添加记录/数据后的主键id 场合：订单表—&gt;物流表 描述：通常我们下了订单之后，会往订单表中添加一条记录，按道理来说在物流表中会记录该订单表中的id，方便查找和区分该订单是由哪个物流来处理的，获取相关的物流信息，当然也可以通过物流中记录的订单id来获取订单表中的信息 实现：（在mybatis映射文件中该如何做?） 方式一： 方式二:","link":"/2020/09/09/Mybatis%E5%9F%BA%E7%A1%80/"},{"title":"MySql常用语法","text":"DDL(数据库/表定义,操作数据库和表结构） 操作数据库创建数据库 create database 数据库名； 查看数据库的字符集 show create database 数据库名; 查看所有的数据库 show databases; 使用数据库 use 数据库名; 删除数据库 drop database 数据库名. 修改数据库字符集 alter database 数据名 character set 字符集; 操作数据表查看表结构/信息 desc 表名; show create table 表名; 查看当前数据库下的所有表 show tables; 查看表的字符集 show table status from 数据库 like “表名”; 创建表 create table 表名( ​ 字段/列名 数据类型 约束， ​ ….. ); 注意:每个字段间用”,”号分割，最后一个字段不需要 常用数据类型 类型 描述 double 类似java中的double int 类似java中的int date 格式:”yyyy-MM-dd” timestamp 时间戳。不给值或为null时采用系统日期时间。 datetime 格式:”yyyy-MM-dd HH:mm:ss” varchar(长度) 类似Java中的字符串,例:varchar(20) 修改表的字段类型 alter table 表名 modify 字段名 字段类型; 修改表名 alter table 旧表名 rename [to] 新表名; 修改表的字符集 alter table 表名 character set 字符集名称; 修改字段名和类型 alter table 表名 change 旧字段名 新字段名 数据类型 ; 添加字段(默认添加到末尾) alter table 表名 add 字段名 字段类型; 添加首字段 alter table 表名 add 字段名 字段类型 first; 在指定字段后添加新字段 alter table 表名 add 新字段名 新字段类型 after 指定字段; 删除字段 alter table 表名 drop 字段名; 删除表 drop table [if exists] 表名; DML(表记录增删改) 添加表数据添加全部列数据 insert into 表名 values(值1,……..); 添加指定列数据 insert into 表名(字段列表) values(值列表); 批量添加指定列数据 insert into 表名(字段列表) values(值列表)，(值列表)…; 批量添加全部列数据 insert into 表名 values(值列表),(值列表)…..; 修改&amp;删除表数据根据条件删除表数据 delete from 表名 where 条件; 根据条件更新表数据 update 表名 set 字段名 = 值1,字段名2 = 值2….. where 条件; 注意:一定要加条件进行修改和删除，否则表中的记录会整体受影响 DQL查询全部 select * from 表名; 查询指定列数据 select 字段列表 from 表名; 起别名查询 select 字段名 [ as] 别名 from 表名; ifnull函数查询 select ifnull(字段名,值) from 表名; 四则运算查询 select 操作数1 运算符 操作数2 from 表名 去重查询 select distinct 字段名 from 表名 条件查询 select ​ 字段列表 from ​ 表列表 where 条件 group by 字段 having 条件 limit 操作数 | 操作数,操作数 聚合函数 函数名 作用 sum() 求和 count() 统计次数 max() 最大值 min() 最小值 avg() 平均值 语法:select 函数名(字段) from 表名; 排序查询语法 select 字段列表 from 表名 order by 字段名 asc | desc; 分组查询语法 select 字段列表 from 表名 group by 字段名 having 条件 分页查询语法 select 字段列表 from 表名 limit 当前页数,查看的记录数; 当前 页数 = （要查看的页数-1）* 查看的记录数 约束 主键约束特点1、主键在一张表中只有一个 2、非空且唯一 添加建表时 create table 表名( ​ 列名 数据类型 primary key， ​ ……. ); 建表后 alter table 表名 modify 字段名 数据类型 primary key; 删除 alter table 表名 drop primary key; 主键自增约束特点通常都是给id设置自动增长，在添加数据的时候直接赋值为null或者default会自动赋值，自动增长的列只能是整数 添加建表时 create table 表名( ​ 字段名 字段类型 primary key auto_increment ​ …… ); 建表后 alter table 表名 modify 字段名 字段类型 auto_increment; 删除 alter table 表名 midfy 字段名 字段类型; 修改自动增长起始值 alter table 表名 auto_increment = 值; 唯一约束添加建表时 create table 表名( ​ 字段名 字段类型 unique, ​ ….. ); 建表后 alter table 表名 modify 字段名 数据类型 unique; 删除 alter table 表名 drop index 字段名; 非空约束添加建表时 create table 表名( ​ 字段名 数据类型 not null, ​ ……. ); 建表后 alter table 表名 modify 字段 字段类型 not null; 删除 alter table 表名 modify 字段 字段类型; 外键约束作用：建立了表与表之间的关联关系。保证了数据的准确性。 添加建表时 create table 表名( ​ 外键列名 外键列类型, ​ constraint 外键名 foreign key (本表外键列名) references 主表表名(主键) ); 建表后 alter table 表名 add constraint 外键名 foreign key(本表外键列名) references 主表表名(主键); 删除 alter table 表名 drop foreign key 外键名; 外键级联更新/删除 删除外键后级联也会随之删除 查看外键名称 show create table 表名; 添加级联更新 alter table 表名 add constraint 外键名 foreign key (本表外键列名) references 主表表名(主键) on update cascade; 添加级联删除 alter table 表名 add constraint 外键名 foreign key (本表外键列名) references 主表表名(主键) on delete cascade; 同时添加 alter table 表名 add constraint 外键名 foreign key (本表外键列名) references 主表表名(主键) on delete cascade on update cascade; 表关系一对一一对多建表原则多的一方添加外键列，建立外键约束，关联一的主键 例如：订单表和用户表、商品分类表和商品表等 多对多建表原则两张表间接建立了多对多的关系，需要创建第三张表，第三张表中关联另外两张表的id 例：用户表和商品表 创建表应该先创建主表，然后在接着创建从表 多表查询内连接查询查询的是两张表外键关联的交集数据 隐式内连接 select 字段列表 from 表1,表2 where 条件 显式内连接 select 字段列表 from 表1 inner join 表2 on/where 条件 外连接查询左外连接查询的是左表全部数据以及左右表的交集数据 select 字段列表 from 表1 left join 表2 on 条件 右外连接查询的是右表全部数据以及左右表的交集数据 select 字段列表 from 表1 right join 表2 on 条件 子查询结果是单行单列作为运算符的条件.比如&lt;、&lt;=、&gt;=、&gt; 、&lt;&gt;等 select 字段列表 from 表名 where 字段名 = (select 字段名 from 表名 [ where 条件]) [where 条件]; 结果是多行单列作为in || not in 的条件 select 字段列表 from 表名 where 字段名 not in (select 字段名 from 表名 [where 条件]) [where 条件]; 结果是多行多列 select 字段列表 from (select 字段列表 from 字段值 [where 条件]) as 别名 [where 条件]; 自关联查询自己查询自己。将自己进行拆分. 比如 ：员工和上级 select * from employee e1 ,employee e2 where e1.mgr = e2.id; 视图将一条较为复杂的查询语句的结果数据保存到视图中，下次还要使用到这个数据，直接查询视图即可，不用再次使用复杂的查询语句 创建视图 create view 视图名称 as 查询语句 ; 查询视图 select * from 视图名称; 修改视图数据 update 视图名称 set 字段名 = 字段值 ,…. where 条件; 修改视图结构命令 alter view 视图名称(字段列表) as 查询语句; 图形化界面 删除视图命令 drop view 视图名称； 图形化界面 注意:操作视图和操作表大同小异 备份和恢复数据库命令方式备份 恢复1、登录数据库 2、删除旧的数据库 3、创建新的数据库 4、使用数据库 5、使用source命令 6、查看是否成功 图形化界面方式备份 恢复1、先删除 2、再创建 3、运行SQL文件即可 存储过程=存储函数=Java中的方法创建1234567delimiter $create procedure 存储过程名([形参])begin -- 方法体 sql语句;end$delimiter ; 存储过程名命令规范:p_功能名 调用1、call 存储名([实参]) 2、call 存储名 3、call 存储名([select语句]) 删除1drop procedure 存储过程名; 查看12-- 查看数据库下面的所有的存储过程select * from mysql.proc where db=&quot;数据库名&quot;; 语法变量定义1declare 变量名 数据类型 [default 值]; 注意:变量只能定义在set之前，不能定义在set后面 1234-- 错误写法declare name varchar(20);set name = &quot;张三&quot;;declare age int; -- 变量只能定义在set语句前面，不能定义在这里 批量定义同类型变量12declare 变量名1,变量名2,变量名3... 数据类型-- 比如 :select address ,name varchar(20) 在Java中也是可以批量定义变量的，比如:String name,address; 赋值(3种方式)1、使用set关键字 1set 变量名 = 值; 2、定义变量并赋值 1declare 变量名 数据类型 default 默认值; 3、将select查询语句的结果赋值给变量 1select 字段名 into 变量名 from 表名 [where 条件]; 注意:mysql中没有扩展赋值运算符&amp;自增自减运算符 变量输出/使用12select 变量名列表;-- 比如 : select 变量名1,变量名2....; If语句单分支123if 条件1 then 条件1成立要执行的代码....end if; 多分支123456789if 条件1 then 条件1成立要执行的代码elseif 条件2 then 条件2成立要执行的代码.....else 以上条件都不成立要执行的代码-- 结束if语句end if; while语句123456初始化语句;while 循环条件 do 循环体代码... 步长/循环条件控制语句..(比如 set num = num + 1;)-- 结束while循环 end while; 建议：不管是if语句还是while语句，先搭建架子，后写逻辑代码 参数传递1、in ： 默认，表示输入参数，类似Java中方法的形参 示例: 12345-- 略...创建存储过程-- 声明p_demo(in name varchar(20))-- 调用call p_demo(&quot;张三&quot;); 2、out: 表示输出参数，可理解为Java中方法的返回值 示例: 123456-- 声明p_demo(out info varchar(20))-- 调用call p_Demo(@info) -- @info 就相当于一个会话变量，用来接收out类型的返回值-- 使用/输出select @info; 存储函数创建12345678delimiter $create function 函数名称([形参])returns 返回值类型begin sql语句; return 值;(值要和类型匹配)end$delimiter ; 函数名命名规范:f_功能名 调用1select 函数名称([实参列表]); -- 类似Java中的，System.out.println(getSum()); 删除1drop function 函数名; 存储过程和存储函数的区别？答：存储过程返回值可有可无，存储函数必须有返回值 Trigger触发器分类1、Insert型触发器 2、Update型触发器3、Delete型触发器 作用1、做数据校验 2、对表数据进行cru时进行日志记录 3、可模拟实现外键的级联删除和更新 创建123456789delimiter $create trigger 触发器名字before|after insert|update|deleteon 表名 -- 对该表名执行cru命令之前或者之后时，会自动触发下面的代码执行for each rowbegin 触发器要执行的代码end$delimiter ; 触发器命名规范：t_表名1__表名2 关键字/对象1、old :表示获取操作操作前/旧的数据,比如:old.id 2、new:表示获取操作后/新的数据,比如:new.name 注意：立场应该放在触发器要执行的代码&amp;执行表名相关代码的立场考虑 查看12-- 查看当前数据库下所有的触发器show triggers; 删除触发器1drop trigger 触发器名; 事务概念一条或多条sql语句组成的一个执行单元，要么同时成功，要么同时失败 特性(ACID)1、原子性:不可分割，要么同时成功，要么同时失败 2、隔离性 3、持久性 4、一致性 隔离级别1、读已提交 2、读未提交 3、可重复读（Mysql默认） 4、串行化 提交方式1、手动提交 2、自动提交（mysql默认） 查看提交方式1select @@AutoCommit; 修改提交方式1set @@Autocommit = 0 | 1; -- 0 表示手动提交 1 表示自动提交 常用操作1、开启事务 1start transaction; 2、提交事务 1commit; 3、回滚事务 1rollback; Mysql中常用函数1、now() :获取当前时间，年月日时分秒 2、curdate() ：获取日期, 年月日 3、concat() ： 用来拼接字符串，比如concat(a,b) ，结果ab,一定要注意拼接的格式 4、substring() ： 用来截取字符串 5、TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)计算两个时间差,还有datediff() 示例: select TIMESTAMPDIFF(year,19920202,CURDATE()) 6、ifnull(字段名,值) 如果字段名的值为null，就用后面的值代替，否则还是用字段名对应的值 7、database() 表示当前数据库 8、year(日期) 获取当前日期中的年，比如year(now())","link":"/2020/09/02/Mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"Mysql常用","slug":"Mysql常用","link":"/tags/Mysql%E5%B8%B8%E7%94%A8/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"Mysql","slug":"Mysql","link":"/categories/Mysql/"}]}