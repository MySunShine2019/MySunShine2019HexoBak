{"pages":[{"title":"","text":"关于我 1、 拒绝敷衍，坚持原创 2、我也是一员努力打拼的码农，在奋斗的路上努力前行。 3、笔名【Java Keep Studying】,本名倪勇,可称呼阿勇或者勇哥均可。 4、 博客作为本人的平时工作学习的产出地方，以此来激励自己学习。 5、该博客属于个人，所有观点也是我个人的观点，跟任何组织机构无关。 6、我是武汉某所专科学校毕业的学渣，专业：计算机应用技术，为了维护学校的尊严，校名就不透露了。后来经过短暂的培训成为了一名正儿八经的程序员。 7、写博文的目的是想沉淀自己的技术，表达自己的所思所想。同时希望能够认识更多的互联网朋友，跟大家一起交流对互联网对科技的认知，聊聊生活上的喜悦和烦恼，分享职场晋升或者面试的经验或者教训 8、在这里，我必须要感谢那些点赞、评论、转发的朋友们，你们的参与是我在写作道路上的最强动力；我也必须要感谢那些赞赏的朋友们，对于原创作者来说，这是最真诚的心意，无关金额的多少。 关注微信公众号 公众号:Java Keep Studying image-20200412115340027 分享内容 专注于JavaSE、数据结构和算法、JavaEE、各种框架、JavaWeb、Mysql、各种实战项目的学习及各种Java学习资源和面试题的分享，希望大家能在技术上得到一定的提升 微信交流群 技术交流为主,开发学习工作中遇到问题可以在微信群交流。欢迎有需要的朋友加群 群规: 群内禁止任何形式的广告，推广，小程序链接等，仅限技术、经验、生活感悟、个人成长等交流。一经发现，立即抱出群外。 联系我 有什么事加微信联系吧，欢迎反馈问题，欢迎交流分享，欢迎互推，欢迎转载文章 个人微信 以下是我微信号的二维码，有兴趣的话，可以加个微信，交个朋友哈哈~ 注:备注来意,具体事项理由！（格式：姓名+目的），否则不予通过，谢谢理解和配合！ 比如：李四 + 转载文章 其他站点博客 1、hexo博客 https://mysuperstart.gitee.io/ 2、CSDN博客 https://blog.csdn.net/qq_41473905","link":"/about/index.html"}],"posts":[{"title":"JDBC:用Java语言操作Mysql数据库","text":"JDBC快速入门步骤0、导入jar包,mysql-connector-java-5.1.37-bin.jar 1、注册驱动 2、获取Connection连接对象 3、获取语句执行者对象 4、定义SQL语句 5、执行SQL语句 6、释放资源 代码展示123456789101112131415161718192021222324252627public class JdbcQuickStart { public static void main(String[] agrs) { // 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 获取链接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///db2&quot;,&quot;root&quot;,&quot;root&quot;); // 定义sql语句 String sql = &quot;select * from student&quot;; // 通过连接对象获取到预编译的语句执行者对象 PreparedStatement ps = conn.prepareStatement(sql); // 执行sql语句 Resultset rs = ps.executeQuery(); // 处理结果 while(rs.next()) { // 获取数据 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getDate(&quot;age&quot;); // 输出 System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+age); } // 释放资源，先开启后关闭 rs.close(); ps.close(); conn.close(); }} JDBC规范中相关API的功能DriverManager1、注册驱动 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 当Driver这个类被加载时，会自动注册驱动。 2、获取链接对象 1Connection conn = DriverManager.getConnection(String url,String username,String password); Connection1、管理事务 123conn.setAutoCommit(false); // 开启事务==手动提交conn.commit(); // 提交事务conn.rollback();// 回退/回滚事务 2、获取语句执行者对象 1234// 获取预编译的语句执行者对象，用于预编译sql语句（推荐） 能够防止sql注入PreparedStatement ps = conn.prepareStatement(String sql);// 获取普通的语句执行者对象（不推荐）Statement state = conn.createStatement(); 3、释放资源 12// 释放资源，先开启后关闭conn.close(); Statement1、执行SQL语句 1234567891011// 采用Statement // 执行DQL，返回结果集对象state.executeQuery(String sql);// 执行DML,返回受影响的行数state.executeUpdate(String sql);// ----------------------------// 采用PreparedStatement// 执行DQL,返回结果集对象ps.executeQuery();// 执行DML，返回受影响的行数ps.executeUpdate(); 2、释放资源 12state.close();ps.close(); ResultSet1、处理结果 12// 获取rs指向的这条数据，然后再把指针向下移动，下次判断再次比较rs指向的位置是否存在数据。rs.next() 2、获取数据 12rs.getXxx(int 列名索引 || String 列名);// Xxx 表示 字段类型 3、释放资源 1rs.close(); DbUtils工具类注：要用下面两个类必须先导入jar包。commons-dbutils-1.6.jar QueryRunner执行sql语句12345678910111213141516// 方式一:// 创建QuertRunner对象QueryRunner queryRunner = new QueryRunner();// 执行DQL类型 变量名 = queryRunner.query(Connection,String,new BeanHandler&lt;&gt;(类型.class)[,Object...parameters]);List&lt;类型&gt; 变量名 = queryRunner.query(Connection,String sql,new BeanListHandler&lt;&gt;(类型.class)[,Object...parameters]);// 执行DQLint 受影响行数 = queryRunner.update(Connection,String sql[,Object...parameters]); // 方式二:QueryRunner queryRunner = new QueryRunner(DataSource);// 执行DML，返回受影响的行数queryRunner.update(String sql[,Object...parameters]);// 执行DQL,返回具体的集合或者对象类型 变量名 = queryRunner.query(String,new BeanHandler&lt;&gt;(类型.class)[,Object...parameters]);List&lt;类型&gt; 变量名 = queryRunner.query(String sql,new BeanListHandler&lt;&gt;(类型.class)[,Object...parameters]); 说明:”[]”括起来的内容可有可无 Dbutils释放资源12DbUtils.close(Connection||Statement||ResultSet);DbUtils.closeQuietly(Connection||Statement||ResultSet); 自定义JDBC工具类1、src目录下创建jdbc.properties配置文件 12345# 驱动类driverClass=com.mysql.jdbc.Driverusername=rootpassword=rooturl=jdbc:mysql://localhost:3306/db1 2、编写工具类JDBCUtils 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class JDBCUtils{ // 1、私有构造 private JDBCUtils() {} // 2、声明配置变量 private static Connection connection; private static String username; private static String password; private static String url; private static String driverClass; // 3、编写静态代码块，读取配置文件，加载驱动 static { try{ // 将配置文件加载进内存，获取对应的字节输入流对象 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); // 创建Properties集合对象 Properties prop = new Properties(); // 将配置文件内容加载到Properties集合中 prop.load(in); // 通过键获取值 username = prop.getProperty(&quot;username&quot;); password = prop.getProperty(&quot;password&quot;); dirverClass = prop.getProperty(&quot;driverClass&quot;); url = prop.getProperty(&quot;url&quot;); // 注册驱动 Class.forName(diverClass); }catch(Exception ex) { ex.printStackTrace(); } } // 4、获取链接Connection对象 public static Connection getConnection() { try { connection = DriverManager.getConnection(url,username,password); }catch(Exception ex){ ex.printStackTrace(); } return connection; } /** * 释放资源 (DQL) * @param resultSet * @param statement * @param conn */ public static void close(ResultSet resultSet , Statement statement,Connection conn) { if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 释放资源 (DML) * @param statement * @param conn */ public static void close(Statement statement,Connection conn) { if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }} sql注入如何产生？使用普通语句执行者对象Statement执行sql语句时容易出现该问题。 核心: or 恒成立式子 ，比如 or 1 = 1，等价于查询所有。 12345678910111213// 获取普通的语句执行者对象Statement state = conn.createStatement();// 定义sql语句String sql = &quot;select * from user where username = zhangsan and password = 123 or 1 = 1&quot;;// 执行sql语句ResultSet set = state.executeQuery(sql);/* 描述: 即使这个zhangsan和123在数据表user中不存在，也会查出user表中的全部记录 坏处： 若前台用户输入的用户名正确，输入的密码是错误的，但是在密码后面加上了 or '1' = '1',此时，若后台采用的是statement来处理相关联的 sql语句时，会引发sql注入的问题。*/ 如何解决？答:使用PrepareStatement对象解决 1234567// 获取预编译语句执行者对象PreparedStatement ps = conn.prepareStatement(&quot;select * from user where username = ? and password = ?&quot;);// 给占位符赋值ps.setString(1,&quot;zhangsan&quot;);ps.setString(2,&quot;123&quot;);// 执行sql语句ResultSet set = ps.executeQuery(); JDBC事务操作1234567891011121314151617// 获取链接对象Connection conn = JDBCUtils.getConnection();// 开启事务 == 手动提交conn.setAutoCommit(false);try{ /* 执行业务逻辑代码(比如：转账)，转入和转出。 代码略... 完成执行这个业务逻辑代码期间要用到的conn对象必须是同一个Connection对象 */ .... // 执行以上代码没有出现任何问题，就提交事务 conn.commit; }catch(Exception ex) { ex.printStackTrace(); // 回滚/回退事务 conn.rollback(); } 注意:必须使用的是同一个Connection连接对象，否则是实现不了事务的效果的","link":"/2020/09/04/JDBC/"},{"title":"自定义数据库连接池&amp;常用第三方数据连接池","text":"什么是数据库连接池？答：就是一个容器，容器里面有很多连接对象 为什么要有数据库连接池？原生JDBC的坏处每次用完链接后都要释放，造成了内存空间的浪费 使用数据库连接池的好处每次用完链接后不是直接释放，而是将链接对象重新归还给了数据库连接池，从而实现了连接对象复用的效果,提高了性能 自定义数据库连接池步骤1、定义个类，实现DataSource接口 2、定义线程安全的成员变量List&lt;Connection&gt; list并初始化 1private static List&lt;Connection&gt; pool = Collections.synchronizedList(new ArrayList&lt;Connection&gt;()); 3、静态代码块，初始化连接数量 4、重写接口中getConnection()方法，获取连接 123456789if(pool.size()&gt;0){ Connection conn = pool.remove(0); // ........ // 使用自定义连接对象，对原有的链接对象进行包装，代码略.... // 使用动态代理的方式完成归还连接，代码略...... return conn;}else{ throw new RuntimeException(&quot;....&quot;);} 5、自定义int getSize()方法，返回数据库连接池中链接对象的数量 6、测试类中测试 归还连接方式一:包装/装饰者设计模式1、定义个类实现Connection接口 2、定义成员变量Connection、List&lt;Connection&gt; 3、通过有参构造初始化成员变量 4、重写接口中close()方法，实现归还连接 5、剩余的方法，调用原有的链接对象中的功能即可 6、在自定义数据库连接池类中，使用定义好的自定义连接对象，对原有的Connection对象进行包装 方式二:适配器设计模式1、定义个适配器类（抽象类），实现Connection接口 2、定义成员变量Connection 3、通过有参构造初始化成员变量 4、重写接口中除了close以外的方法 5、定义个类继承适配器类6、定义成员变量Connection、List&lt;Connection&gt; 7、带参构造对成员变量进行赋值 8，重写close方法,实现归还连接 9、在自定义数据库连接池类中，使用定义好的自定义连接对象，对原有的Connection对象进行包装 方式三:JDK动态代理概念在不改变目标类的代码的基础上，对目标类中的方法进行增强 组成代理对象：表示目标对象 被代理对象：内存中动态生成的一个对象 前提必须要有一个接口和实现类(目标类) 使用12345678910Proxy.newProxyInstance(ClassLoader,Class&lt;?&gt;[] interfaces,InvocationHandler)/*ClassLoader：代理对象和被代理必须实现相同的类加载器Class&lt;?&gt;[] interfaces ： 表示代理对象必须和被代理对象实现相同的接口InvocationHandler ： 表示代理规则，也就是要增强的功能 invoke(Object proxy,Method method,Obkecy[] args) 动态代理对象每次执行方法时都会经过该invoke方法 proxy ： 我们不需关心 method： 当前代理对象执行的是哪个方法，这个method就指代该成员方法对象 args : 代理对象执行方法时，传递的参数会封装到这个args数组中*/ 代码展示123456789101112131415161718192021222324252627282930public class Student implements StudentInter{ public void study(){ &quot;在家自学&quot;.sout; } public void eat(String name) { &quot;正在吃&quot;+name.sout; }}interface StudentInter{ void study(); void eat(String name);}class ProxyTest{ public static void main(String[] args){ // 创建Student对象 Student stu = new Student(); // 在内存中创建动态代理对象 StudentInter stuProxy = (StudentInter)Proxy.newProxyInstance(stu.getClass().getClassLoader(),new Class[]{StudentInter.class},(proxy,method,agr)-&gt;{ if(method.getName(&quot;study&quot;)){ &quot;在培训机构学习&quot;.sout return null; }else{ return method.invoke(stu,arg); } }); // 调用方法 stuProxy.eat(&quot;米饭&quot;); stuProxy.study(); } } 使用JDK动态代理实现归还连接的核心代码12345678910Connection targetConn = (Connection)Proxy.newProxyInstance(conn.getClass().getClassLoader(),new Class[]{Connection.class},(proxy,method,arg)-&gt;{ if(method.getName().equals(&quot;close&quot;)) { // 归还连接 pool.add(conn); return null; }else{ // 如果不是close方法，直接调用原有Connection连接对象的方法即可 return method.invoke(conn,arg); }}) 执行流程 常用第三方数据库连接池技术c3p0步骤1、导入jar包&amp;c3p0-config.xml||c3p0.properties文件、 c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 2、创建c3p0数据库连接池对象 ComboPooledDataSource(String configName)// 采用指定配置 ComboPooledDataSource() // 采用默认配置 3、获取链接对象 代码展示12345678910111213141516171819202122232425262728public class C3P0Test { public static void main(String[] args) { // 采用默认配置，创建C3P0数据库连接池对象 DataSource dataSource = new ComboPooledDataSource(); // 获取链接对象 Connection conn = dataSource.getConnection(); // 定义sql语句 String sql = &quot;select * from student&quot;; // 通过链接对象获取预编译语句执行者对象 PreparedStatement statement = conn.prepareStatement(sql); // 执行sql语句，返回结果集对象 ResultSet rs = statement.executeQuery(); // 处理结果集 while(rs.next()) { // 获取数据 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); // 打印 System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+age); } // 释放资源 rs.close(); statement.close(); // 归还连接 conn.close(); }} Druid(最常用)步骤1、导入jar包&amp;xxxxx.properties配置文件 druid-1.0.9.jar 2、加载配置文件（提示:prop.load(is)） 2、通过Druid数据库连接池工厂创建连接池对象 1DruidDataSourceFactory.createDataSource(Map|Properties); 3、获取链接 代码展示1234567891011121314151617181920212223242526272829303132public class DruidTest { public static void main(String[] args) throws Exception { // 通过类加载器将配置文件加载进内存，返回一个字节输入流对象 InputStream is = DruidTest.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); // 创建Properties集合 Properties prop = new Properties(); // 将配置文件中的键值对信息加载到Properties集合中 prop.load(is); // 通过Druid数据库连接池工厂类的静态方法createDataSource(Map|Properties)来创建数据库连接池对象 DataSource ds = DruidDataSourceFactory.createDatSource(prop); // 获取链接对象 Connection conn = prop.getConnection(); // 定义sql语句 String sql = &quot;select * from student&quot;; // 通过链接对象获取预编译语句执行者对象 PreparedStatement ps = conn.prepareStatement(sql); // 执行sql语句,返回结果集对象 ResultSet set = ps.executeQuery(); // 处理结果集 while(set.next()) { int id = set.getInt(&quot;id&quot;); String name = set.getString(&quot;name&quot;); int age = set.getInt(&quot;age&quot;); System.out.println(id+&quot;\\t&quot;+name+&quot;\\t&quot;+age) } //释放资源 rs.close(); ps.close(); // 归还连接 conn.close(); }} 拓展：在该jar包中有个工具类JdbcUtils c3p0&amp;Druid区别？ 区别 描述 导入的jar包数量 c3p0要导入两个jar包，druid只需导入一个。 配置文件所在位置及文件名 c3p0配置文件名只能是c3p0-config.xml或者c3p0.properties。druid配置文件名无硬性要求。比如:任意文件名.properties文件都可以。不管是druid还是c3p0，配置文件都必须放在src目录下 是否自动加载配置文件 c3p0在创建数据库连接池对象时会自动加载配置文件,druid不会自动加载配置文件，需要手动加载，通过静态代码块可以完成加载 close方法 不管是druid还是c3p0，close方法都会自动归还链接 获取数据库连接池对象所采用Api c3p0使用的是ComboPooledDatSource([String configname])构造来完成数据库连接池的初始化 ,Druid使用的是DruidDataSourceFactory.createDataSource(Map|Properties)来实现数据库连接池的初始化 数据库连接池工具类步骤1、私有构造 2、声明静态数据源变量DataSource 2、静态代码块(读取配置文件、初始化数据源DataSource) 3、获取链接对象 4、释放链接 5、获取数据库连接池对象DataSource 代码展示(以Druid数据库连接池工具类为例)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class DruidDataSourceUtils{ // 私有构造 private DruidDataSourceUtils(){} // 声明数据源变量 private static DataSource dataSource; // 静态代码块 static{ try{ // 将配置文件加载进内存，返回字节输入流对象 InputStream is = DruidDataSourceUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); // 创建Properties集合对象，用来装载配置文件信息 Properties prop = new Properties(); // 将配置文件中的内容加载到Properties集合中 prop.load(is); // 通过Druid数据库连接池工厂的静态方法createDataSource(Map|Properties)创建数据源对象 dataSource = DruidDateSourceFactory.createDataSource(prop); }catch(Exception ex){ ex.printStackTrace(); } } // 获取链接对象 public static Connection getConnection(){ Collection conn = null; try{ // 获取链接对象 conn = dataSource.getConnection(); }catch(Exception ex) { ex.printStackTrace(); } return conn; } // 获取数据库连接池对象 public static DataSource getDataSource(){ return dataSource; } // 释放资源 public static void close(ResultSet rs,Statement state,Connection conn) { if(rs != null) { try{ rs.close() }catch(Exception ex){ ex.printStackTrace(); } } // ....... } public static void close(Statement state,Connection conn) { if(state != null){ try{ state.close(); }catch(Exception ex){ ex.printStackTrace(); } } // ....... }}","link":"/2020/09/07/JDBC%E9%AB%98%E7%BA%A7/"},{"title":"JavaScript基础语法、DOM文档对象模型、JavaScript常用事件","text":"JavaScript概念是一门客服端浏览器的弱类型脚本语言，简称Js 作用能让网页动起来，增强用户和 HTML 页面的交互过程 组成由ECMAScript、DOM、BOM组成 引入方式内部引入只能在当前html页面中生效 1&lt;script&gt;js代码&lt;/script&gt; 外部引入通用的js代码都会抽取到文件中放，方便重用 1&lt;script src=&quot;js文件&quot;&gt;&lt;/script&gt; 注意事项若是通过外部引入方式引入的，则标签体中不能再写Js代码，比如: 1&lt;script src=&quot;js文件&quot;&gt;js代码&lt;/script&gt; &lt;!--这样写是错误的--&gt; 注意：JavaScript是解释性语言，从上往下边解释边执行 ECMAScript输入&amp;输出语句 语法 说明 console.log(内容) 将内容输出到控制台,F12 alert(内容) 弹出框 prompt(内容) 询问框 document.write(内容) 可输出标签及普通文本 console.log()&amp;alert() 用的比较多，多用于程序调试 也可以这样使用:window.prompt(内容). 变量&amp;常量局部变量12var 变量名 = 值;let 变量名 = 值; // ECMAScript6新语法 成员变量1变量名 = 值; 原始数据类型(6种)js中是由值来决定类型的，和java不同，java是强类型，js是弱类型。 类型 说明 string 和java一样 number 浮点数、整数。nan也属于number类型 null 声明null值的特殊关键字 undefined 只定义未赋值，比如 int num; console.log(typeof num) bigint 大整数。int num = 10n; console.log(typeof num); boolean 和java一样 js中所有的对象都属于object类型，int obj = null, console.log(typeof obj),空值null，也属于object类型 查看变量的类型typeof 变量名 typeof(变量名) 拓展局部代码块 123456{ let num = 10; num1 = 20; }document.write(num);// 错误docuemnt.write(num1);// 正确 如果在js代码出错了，可以在客服端浏览器上按F12进行查看或者调试 运算符比较运算符== : 比较值 1var flag = &quot;8&quot; == 8;// true === ： 先比较类型，后比较值，若类型不相等直接返回false，若类型相等在比较值。 1var flag = &quot;8&quot; === 8;// false 算术运算符数值型字符串在进行算术运算时，若执行+ 运算, 会执行字符串拼接，若执行的是减乘除运算会进行隐式类型转换 , 将数值型字符串转换为numer类型进行运算，如果转换失败, 会返回NAN(not a number ) 1234let num = &quot;8&quot; + 8; // 88var num = &quot;10&quot; - 5 ; //5var num = &quot;10&quot; * 5 ; //50var num = &quot;10&quot; / 5 ; //2 逻辑运算符js中没有逻辑与&amp;和逻辑或| 原始数据类型和boolean类型之间的转换在js判断语句中，若判断的变量类型不是boolean类型，js会自动进行类型转换，转换成boolean类型，在进行判断. 类型 转boolean string 非空串为true,空串””为false number 非0为true,0为false null 转为false undefined 转为false bigint 非0为true，0为false object js中所有的对象Object转换成boolean都是true 流程控制语句for循环123for(var i = 0;i&lt;10;i++){ console.log(i);} 运算符和流程控制语句，我在这里只列出一部分，这些部分都是和java有些区别的。其他我没列出来的，大部分都和java一样，我在这里就不描述了。 数组特点数据类型和长度无限制。和java不同 定义格式12var 数组名 = [元素列表];// 多个元素之间采用&quot;,&quot;号分割 数组高级运算符…数组合并语法: var 数组名 = [数组列表]; 1var arr = [...arr1,...arr2]; 数组复制语法:var 数组名 = […数组对象]; 1var arr = [...arr1]; 字符串转成数组语法:var 数组名 = […”字符串”]; 1var 数组名 = [...&quot;hello&quot;]; 扩展数组转成字符串语法:数组名.join(“连接符”) 1var str = arr.join(&quot;,&quot;); 向数组中追加元素语法：数组名.push(元素) / 数组名[数组名.length] = 值; 12var num = 10;arr.push(num); 取出/弹出数组中的元素语法:数组名.pop() 1234arr=[1,2,3,4];for (var i = arr.length - 1;i&gt;=0;i--){ document.write(arr.pop()+&quot;&lt;br&gt;&quot;);} 注意事项1、js中没有数组的索引越界异常 比如: 12let arr = [1,2,3];arr[10] = &quot;hello&quot;; 这样是可以的 函数[对象]定义格式&amp;调用普通1234function 函数名([形参列表]){ // 方法体 [return 值;]} 调用函数名(); 匿名1234let 函数名 = function ([形参列表]){ // 方法体 [return 值;]} 调用函数名(); 匿名函数通常配合事件一起使用 注意事项1、js中函数没有重载，就近调用，后面声明的方法会覆盖掉前面的 2、实参个数&gt;形参个数，只取有效部分 DOM 概念DOM(Document Object Model)：文档对象模型 将 HTML 文档的各个组成部分，封装为对象。借助这些对象，可以对 HTML 文档进行增删改查的动态操作。 Document文档对象document表示当前整个html文档对象，通过该对象可以动态创建元素对象，获取当前html文档中的元素对象等。 Element元素对象获取Element标签元素 方法名 描述 getElementById(“id值”) 通过id值获取元素对象 getElementsByTagName(“标签名”) 通过标签名获取多个元素对象 getElementsByName(“name属性值”) 通过name属性值获取多个元素对象 getElementsByClassName(“class属性值”) 通过class属性值获取多个元素对象 子元素对象.parentElement属性 获取子元素对象的父元素对象 增删改Element标签元素 方法名 描述 appendChild(子元素) 添加子元素 removeChild(子元素) 删除子元素 replaceChild(新元素，旧元素) 用新元素替换掉旧元素 createElement(“标签名称”) 创建元素对象 Attribute属性对象 方法名 描述 setAttribute(“属性名”,”属性值”) 设置(添加)/修改属性 removeAttribute(“属性名”) 删除属性 getAttribute(“属性名”) 通过属性名获取属性值 style属性 设置样式,比如:元素对象.style.样式名称=“值” className 引用存在的class样式,比如:元素对象.className=”class值” 除了上面列出的以外，还有很多属性都可以自己尝试,比如:value、checked等 Text文本对象 属性名 说明 innerText 添加/获取文本内容，不解析标签 innerHTML 添加/获取文本内容，解析标签 123456// 获取document.write(元素对象.innerText);document.write(元素对象.innerHtml);// 设置元素对象.innerHtml= &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;;元素对象.innerText = &quot;hello&quot;; Node结点对象createTextNode(文本内容)：创建文本结点对象 例12let text = document.createTextNode(&quot;删除&quot;);a.appendChild(text); 事件概念事件指的就是当某些组件执行了某些操作后，会触发某些代码的执行。比如：车铃 常用事件(9个) 事件名 描述 onload 页面加载完后会触发该事件 onsubmit 表单提交时会触发该事件 onclick 鼠标单击事件 ondblclick 鼠标双击事件 onblur 元素失去焦点事件 onfocus 元素获取焦点事件 onchange 改变后后触发该事件，通常和下拉列表一起使用，做省市联动等 onmouseover 鼠标移入元素时会触发该事件 onmouseout 鼠标移出元素时会触发该事件 绑定事件的方式1、通过标签中的事件属性进行绑定。 1&lt;标签名 事件属性=&quot;js代码|函数&quot; &gt;&lt;/标签名&gt; 比如: 1&lt;botton type=&quot;button&quot; id=&quot;btn&quot; onclick=&quot;fun1()&quot;&gt;点我呀&lt;/botton&gt; 2、通过 DOM 元素属性绑定。 1元素对象.事件属性 = 函数对象|匿名函数 比如: 1document.getElementById(&quot;btn&quot;).onclick=fun1; 通常情况下，都是采用第二种方式来绑定事件，这样就降低了js和html代码之间的耦合度。 事件中的this关键字123456789101112131415161718192021222324252627282930313233&lt;!--第一种方式 不使用this--&gt;&lt;button onclick=&quot;fun1()&quot;&gt;点我呀&lt;/button&gt;&lt;script&gt; function fun1() { document.getElementsByTagName(&quot;button&quot;)[0].style.background=&quot;red&quot;; }&lt;/script&gt;&lt;!--第二种方式--&gt;&lt;button onclick=&quot;fun1(this)&quot;&gt;点我呀&lt;/button&gt;&lt;script&gt; function fun1(obj){ // obj : 表示当前触发该事件的元素对象 obj.className=&quot;footer&quot;; }&lt;/script&gt;&lt;!--第三种方式--&gt;&lt;button&gt;点我呀&lt;/button&gt;&lt;script&gt; document.getElementsByTageName(&quot;button&quot;)[0].onclick=function() { this.style.background=&quot;blue&quot;; }&lt;/script&gt;&lt;!--第四种方式--&gt;&lt;button&gt; 点我呀&lt;/button&gt;&lt;script&gt; function fun(){ this.style.background=&quot;bule&quot;; } document.getElementsByTagName(&quot;button&quot;)[0].onclick=fun;&lt;/script&gt; 小知识1、input 的type属性值 type=”result” 表示 重置按钮 type=”submit” 表示提交按钮 type=”button” 表示普通按钮 2、href=”javascript:void(0);” ：表示禁止刷新 3、表单中的每个表单项也有auto……那个是否自动补全的那个属性。 4、通用操作. 12345678// 获取到value属性值var name = document.getElementById(&quot;name&quot;).value;var age = document.getElementById(&quot;age&quot;).value;var gender = document.getElementById(&quot;gender&quot;).value;// 拼接 let str = &quot;&lt;tr&gt;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;;// 设置文本内容，包含标签document.getElmentById(&quot;tb&quot;).innerHtml+=str;","link":"/2020/09/12/JavaScript%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"title":"Java程序必备的JavaScript知识","text":"创建JavaScript对象创建12345678910let 对象名 = { 属性名 ： 属性值， //... 方法名 : function([形参列表]) { // 方法体 [return 值;] }}// 表示形式 ： 键值对的形式来表示的// 属性名 可以 采用 字符串的形式表示 使用123456// 访问属性值对象名.属性名;// 设置/修改对象名.属性名 = 值;// 调用方法对象名.方法名([实参列表]); JavaScript常用内置对象Math 方法名 作用 ceil(值) 向上取整 floor(值) 向下取整 round(值) 四舍五入 pow(x,y) 求次幂 random() 生成[0,1)的随机数 Number 方法名 作用 parseInt(值) 将值转换为Int parseFloat(值) 将值转换为Float RegExp正则表达式作用做数据校验 定义/创建正则对象 let 对象名 = new RegExp(“正则规则”); let 对象名 = /^正则规则$/ 校验数据，判断字符串是否符合正则规则 test(字符串|字符串变量) 返回true表示校验成功，返回false表示校验失败，一般返回false我们都会阻止表单提交 规则 规则，我在这里不过多介绍，Java程序能看懂正则，能用就可以了。（找百度） Array创建数组的格式 let 数组名 = new Array(元素列表); let 数组名 = [元素列表]； 多个元素之间采用英文逗号”,”进行分割 方法名 作用 reverse() 反转 sort（） 排序 shift() 删除首元素并返回 pop() 删除末尾元素并返回 push(元素) 末尾追加元素 includes(元素) 判断数组中是否包含指定的元素，包含返回true，不包含返回false Date日期创建 let 对象名 = new Date(); // 当前系统时间 let 对象名 = new Date(毫秒值);// 时间原点东八区1970-01-01 08:00:00 + 指定毫秒值后的时间 let 对象名 = new Date(年,月[,日,时，分，秒]); // 注意：月取值范围[0,11] String创建 let 对象名 = new String(“值”); let 对象名 = “值”; 方法名 描述 replace(old,new) 用旧的字符串替换新的字符串，通常用于替换铭感信息 indexOf(子串) 获取子串在主串中首次出现的索引 lastIndexOf(子串) 获取子串在主串中最后一次出现的索引 length属性 获取字符串中字符的个数 substring(startIndex,endIndex) 截取子串,[startIndex,endIndex) charAt(index) 获取指定索引位置的字符 split(“分割符”) 将字符串按照指定的分割符进行分割，返回分割后的元素数组 Set创建 let 对象名 = new Set(); 方法名 描述 add(元素) 添加元素 size属性 查看集合中元素的个数 delete(元素) 删除元素，成功返回true，失败返回false keys() 获取set集合的迭代器对象 Map创建 let 对象名 = new Map()； 方法名 作用描述 entries() 获取Map集合对象的迭代器对象 set(K,V) 添加键值对元素 delete(key) 根据键删除键值对元素，删除成功返回true，否则false size属性 获取map集合中键值对的对数 get(key) 通过键获取值 JSON概念：Json可以理解为就是一种特殊的字符串，用来做数据传递 方法名 作用描述 stringify(js对象) 将Js对象|数组转换为json字符串 parse(json字符串) 将json字符串解析成js对象|数组 这些方法都是静态方法，直接调用即可,比如:JSON.parse(json字符串) BOM浏览器对象模型BOM:Brower Object Model，就是将浏览器各个组成部分封装成js对象，方便操作浏览器。 Location地址栏对象href属性设置&amp;获取1234// 获取location.href// 设置location.href = &quot;资源路径&quot;; Window窗口对象定时器一次性定时器1234// 设置一次性定时器，返回一个唯一标识，唯一标识用于清除定时器时使用唯一标识 [window.]setTimeout(匿名函数|&quot;函数名()&quot;,毫秒值); // 清除一次性定时器clearTimeout(唯一标识); 循环定时器1234// 设置循环定时器.返回一个唯一标识，唯一标识用于清除定时器时使用唯一标识 setInterval(匿名函数|&quot;函数名()&quot;,毫秒值);// 清除循环定时器clearInterval(唯一标识); onload事件页面加载完后，会自动触发该事件。 示例1234window.onload = function () { // 方法体 [return 值;]} 案例表单校验技术： 1、 RegExp 创建 校验 2、DOM 动态广告技术： 1、 循环定时器 2、display属性 none : 隐藏 block : 显示 3、DOM","link":"/2020/09/14/JavaScript%E7%AC%AC%E4%BA%8C%E5%A4%A9/"},{"title":"Mybatis框架第一天","text":"什么是框架？框架就是一个半成品软件，框架很多东西都给我们实现了，我们只需遵守框架的规则进行学习 什么是ORM?ORM：对象关系映射 也就是让Java对象和关系型数据库产生关联。产生关联后，我们操作Java对象就像是在操作数据表 表与实体类的映射规则表名对应Java实体类 表中字段对应Java实体类中的成员变量 表中每条记录对应该类的每个对象 原生Jdbc的缺点 1、sql硬编码，不易维护 2、DQL需手动封装数据 3、DML需手动给占位符赋值 4、频繁开启&amp;释放链接 解决办法 4—&gt;使用数据库连接池，每次归还连接 2、3—&gt;使用反射&amp;内省技术完成 什么是Mybatis框架？基础Java一个ORM框架，底层封装了对Jdbc的操作 Idea上连接Mysql数据库 ​ Mybatis入门程序步骤： 0、导入jar包 0.1、mysql驱动jar包 0.2、mybatis核心jia包 若想进行测试导入单元测试的jar包也是可以的 1、创建数据表 2、创建实体类 3、编写Mybatis核心配置文件 4、编写Mybatis映射文件 5、测试 Mybatis相关apiResource：加载类加载路径下的配置文件 getResourceAsStream(“核心配置文件.xml”) SqlSessionFactoryBuilder:采用构建者模式构建SqlSessionFactory对象 builder(InputStream|Reader,[String 环境名称]) SqlSessionFactory:采用工厂模式构建SqlSession对象 openssion(boolean) true:表示自动提交 false表示手动提交 注意：增删改需要提交事务，手动/自动提交都可以 SqlSession：会话对象，就相当于Jdbc中的Connection连接对象 执行sql selectList(“namespace.id值”[,Object obj]) selectOne(“namespace.id值”[,Object obj]) update(“namespace.id值”,(,Object obj)) insert(“namespace.id值”[,Object obj]) delete(“namespace.id值”,[,Object obj]) 管理事务 commit() : 提交事务 rollback() ： 回滚事务 Mybatis映射文件的配置标签 select insert update delete 属性 namespace:名称空间，用来区分各个mybatis映射文件，防止冲突.该属性就相当于java中的包,java中的包是用来管理java类的，而namespace是用来管理这些mybatis映射文件的 比如： AMapper.xml中有个findAll，BMapper.xml中也有一个findAll，去执行这个findAll的时候，mybatis框架是不知道我们具体要执行哪个xml文件中的findAll的，只有使用了namespace属性进行区分mybatis框架才知道具体要执行哪个findAll. id:唯一标识。 paramerType:表示参数类型（可以省略不写） resultType:表示结果集类型。也就是select语句执行完后返回的结果会封装到你指定的这个resultType类型中，返回到调用这个sql语句的地方进行使用。只有select才有resultType. Mybatis核心配置文件配置数据库环境 环境多选一 配置映射 1234567&lt;mappers&gt; &lt;!-- url:网络中的路径 resource:最常用,指定项目中Mybatis映射文件所在的位置--&gt; &lt;mappers resource=&quot;com/UserMapper.xml&quot;&gt;&lt;/mappers&gt;&lt;/mappers&gt; 配置类型别名 配置前 resultType=”io.domian.Student” 配置后 resultType=”student” 坏处：打印日志中可能会出现乱码 配置日志 123&lt;settings&gt; &lt;setting&gt;&lt;/setting&gt;&lt;/settings&gt; 加载属性配置文件 1 需要注意标签出现的先后顺序，出现问题后光标悬停在跟标签上（推荐），会有提示。当然你查看mybatis的约束文件(不推荐)也是可以的. 如何实现Mybatis框架执行Sql语句的日志记录？（采用Log4j） 实现步骤： 1、导入jar包 2、src下导入配置文件 3、核心配置文件中配置&lt;settings&gt; Mybatis取值方式 1、ognl表达式 2、EL表达式 ognl表达式 好处：防止sql注入漏洞。预编译sql时采用的占位符?,然后在将传进来的值依次给占位符赋值 缺点：模糊查询 ,’%#{username}%’不可行，也可以这样selectList(“…..”,”%huang%”) ,然后 like #{username} El表达式 好处：模糊查询 ，‘%${username}%’可行 缺点：引发sql注入漏洞。直接将传进来的值拼接到sql上了 单值参数，名称任意 比如:select * from student where id = #{xxxx} 多值参数，名称不可任意 比如:insert into student values(#{id},#{name},#{age}) #{内容}：内容一般都代表唯一的键或者属性名,比如map集合的键 假设传进来的是一个map集合(insert(“….”,map)) #{gender}:就表示根据这个gender键获取对应的值 假设传进来的是一个Student对象(insert(“…”,student)) #{id}：就相当于调用了该对象的getId()方法获取了该对象的值 获取添加记录/数据后的主键id 场合：订单表—&gt;物流表 描述：通常我们下了订单之后，会往订单表中添加一条记录，按道理来说在物流表中会记录该订单表中的id，方便查找和区分该订单是由哪个物流来处理的，获取相关的物流信息，当然也可以通过物流中记录的订单id来获取订单表中的信息 实现：（在mybatis映射文件中该如何做?） 方式一： 方式二:","link":"/2020/09/09/Mybatis%E5%9F%BA%E7%A1%80/"},{"title":"Mybatis接口代理&amp;多表查询","text":"MyBatis接口代理规范1、namespace=”数据访问层接口的全限定名” 2、id=”接口方法名” 3、parameterType=”接口方法形参类型”,(可省略不写) 4、resultType=”接口方法的返回值类型” 只有遵守这些规范，才能让接口和映射文件产生关联映射 实现原理1、sqlSession.getMapper(接口类型.class)，通过JDK动态代理创建了该接口代理实现类对象 2、每次代理对象执行方法时，都会经过Invocation中的invoke方法 使用接口代理好处1、省去写数据访问层接口实现类的烦恼 2、避免了每次定位Sql,防止写错。 以前 : sqlSession.select(“namespace.statemetId值”) 动态SQL什么是动态SQL？不同的需求，SQL也不同，SQL根据条件自动生成、拼接 &lt;where&gt;标签作用：用来做条件查询 例12345678910select * from student&lt;where&gt; &lt;if test=&quot;name!=null and name!=''&quot;&gt; and name like concat('%',#{name},'%') &lt;/if&gt;&lt;/where&gt;select * from student where 1 = 1&lt;if test=&quot;name != null and name != ''&quot;&gt; and name like concat('%',${name},'%')&lt;/if&gt; &lt;if&gt;标签作用：对参入的参数进行判断(比如：非空判断等) 属性：test 例单条件&lt;if&gt; 123&lt;if test=&quot;name!=null and name != ''&quot;&gt; and name like #{name}&lt;/if&gt; 多条件&lt;if&gt; 123456&lt;if test=&quot;age != null&quot;&gt; and age = #{age}&lt;/if&gt;&lt;if test=&quot;array!=null and array.length != 0&quot;&gt; &lt;/if&gt; &lt;foreach&gt;标签作用：对传入的参数进行循环/遍历(比如:数组、集合等容器) 使用场合: in ，范围遍历查找 属性: 属性名 作用 open 遍历的开始字符串 close 遍历的结束字符串 collection 数组–&gt;array,可变参–&gt;array,对象–&gt;属性名,Map集合–&gt;key,List集合–&gt;list separator 分隔符 item 表示每个元素项 index 索引 例1234&lt;!--对象--&gt;&lt;foreach open=&quot;id in (&quot; separator=&quot;,&quot; item=&quot;id&quot; collection=&quot;attributeName&quot; close=&quot;)&quot;&gt;&lt;/foreach&gt;&lt;!--map集合--&gt;&lt;foreach open=&quot;id in (&quot; separator=&quot;,&quot; item=&quot;id&quot; collection=&quot;key&quot; close=&quot;)&quot;&gt;&lt;/foreach&gt; 拓展&lt; 用 &amp;lt;|CD区 &gt;用&amp;gt; | CD区 Mybatis分页插件使用步骤 1、导入jar包 2、mybatis核心配置文件中配置分页插件 1234567&lt;plugins&gt; &lt;!--配置mybatis分页插件--&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!--配置方言，我这里使用的mysql，value就为mysql,若你的是oracle这里就要配置oracle--&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 3、在执行查询语句之前开启分页 123pageHelper.start(Integer pageNo,Integer pageSize);// pageNo：当前要查看的页码// pageSize：每页所展示的条数 代码实现（伪代码）123456789101112131415161718public class StudentServiceImpl implement StudentService{ public List&lt;Student&gt; findAll() { // 1、加载核心配置文件 // 略.... // 2、采用SqlSessionFactoryBuilder对象，通过构建者模式构建出SqlSessionFactory对象 // 略.... // 3、采用SqlSession工厂对象SqlSessionFactory对象，获取sqlSession对象 // 略.... // 4、调用sqlSession的getMapper(接口类型.class)方法，通过JDK动态代理的方式动态在内存中产生接口代理的实现类对象 StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); // 调用方法，（执行sql语句，封装结果，返回）---&gt;Mybatis都自动帮我们完成了 List&lt;Student&gt; stuList = studentMapper.findAll(); return stuList; // 释放资源(代码包裹在finally代码块中) // 略.... }} SQL片段抽取如何抽取？1234&lt;!--id表示唯一标识--&gt;&lt;sql id=&quot;值&quot;&gt; &lt;!--这里面写要进行重用的sql语句|字段--&gt;&lt;/sql&gt; 例1234&lt;sql id=&quot;Base_Column_List&quot;&gt; &lt;!--@mbg.generated--&gt; id, `name`, age&lt;/sql&gt; 如何调用？1&lt;include refid=&quot;已存在的sql片段的id值&quot;/&gt; 例1&lt;include refid=&quot;Base_Column_List&quot;/&gt; Mybatis多表查询/操作表关联关系1、一对一 比如:人和身份证2、一对多 比如：班级、学生 3、多对多 注意：多对多其实也是一个双向的一对多 比如： 一门课程可以被多个学生选 一个学生也可以选多门课程 其实，可以理解为Mybatis中只有一对一和一对多的关系、多对多时包含在一对多关系中的 一对一以身份证和人为例，一个人只能有一个身份证号 步骤0、准备数据 1、建立实体类映射关系 通常都是在功能/查询主体的一方建立实体类一对一的映射关系 比如：有这样一个需求：查询id=1的人的详情信息及其身份证信息 此时，我们需要明确的是功能主体是人，我们就需要在Person实体类中建立实现类映射关系 代码： 123456789101112131415161718192021public class Person { // 成员变量 private Integer id; private String name; private Integer age; /* 建立实体类映射关系:一对一关系 */ private Card card; // getter&amp;setter&amp;toString方法 // 略...}public class Card{ private Integer id; private String number; private Integer pid; // getter&amp;setter&amp;toString方法 // 略...} 2、编写sql语句 123&lt;select id=&quot;findByIdWithCard&quot; resultMap=&quot;Person_Card_Map&quot;&gt; select 字段列表 from person p ,card c where id = 1 where id = #{id} and p.id=c.pid;&lt;/select&gt; 注意：字段列表不要有同名的，否则mybatis框架不知道到底要封装哪个字段 3、编写结果集映射 结果集映射：告诉Mybatis框架，sql语句执行的结果该怎样进行封装 12345678910111213141516171819202122&lt;!-- resultMap id:表示唯一标识，用来区分结果集映射 type:表示功能主体的类型、对象--&gt;&lt;resultMap id=&quot;Person_Card_Map&quot; type=&quot;person&quot;&gt; &lt;!-- 配置主键id映射 column对应sql语句查询出来的结果中的列名 property对应实体类中setXxx，改X为x后的属性名 也就是指定你要将哪个列名所对应的值封装到这个person对象的哪个属性中去 --&gt; &lt;id column=&quot;cid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;!-- 配置其他字段映射 --&gt; &lt;result property=&quot;name&quot; column=&quot;cname&quot;&gt;&lt;/result&gt; &lt;!--建立一对一关系映射--&gt; &lt;association property=&quot;category&quot; javaType=&quot;Category&quot;&gt; &lt;id column=&quot;cname&quot; property=&quot;name&quot;&gt;&lt;/id&gt; &lt;result property=&quot;seq&quot; column=&quot;seq&quot;&gt;&lt;/result&gt; &lt;result column=&quot;category_id&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多一对多和一对一的实现大致步骤都是一样的，我在这里只按需分析它们的区别 以班级、学生为例，一个班中有很多学生，需求：查询每个班中所有的学生 分析：功能主体就是班级，所以我们应该在班级实体类中去建立一对多的关系，如下所示: 123456789101112public class Classes{ /* 建立实体类之间一对多的映射关系 */ private List&lt;Student&gt; stuList; // getter&amp;setter&amp;toString&amp;otherfield // 略...}public class Student { // getter&amp;setter&amp;toString&amp;otherfield // 略...} 结果集映射区别 123456789101112&lt;resultMap id=&quot;Classes_Student_Map&quot; type=&quot;classes&quot;&gt; &lt;!--略....--&gt; &lt;!-- 建立一对多关系结果集映射 property 表示结果集数据要封装到哪个属性容器中去 javaType 表示你这个属性容器是什么类型的 ofType 表示属性容器中每个元素的类型是什么 --&gt; &lt;collection javaType=&quot;list&quot; property=&quot;stuList&quot; ofType=&quot;Student&quot;&gt; &lt;!--略....--&gt; &lt;/collection&gt;&lt;/resultMap&gt; 多对多实现步骤、思路和一对多时一样的，唯一区别：体现在sql语句上，要关联第三张表 例1public abstract Student findByIdWithCource(Integer id); 1234&lt;select id=&quot;findByIdWithCourse&quot; resultMap=&quot;Student_Cource_Map&quot;&gt; &lt;!-- 根据学生id查询学生信息以及学生所选的课程信息 --&gt; select s.id,s.name,s.age,c.id cid,c.name cname from student s,course c,stu_ke sk where sk.sid = s.id and sk.cid = c.id and s.id = #{id}&lt;/select&gt; 总结多表规律一定要先找出查询的主体，角度不同，查询主题不同，关系不同。只有多表查询才是需要建立结果集映射的，单表建立结果集映射是没有意义的 加载映射配置单个123&lt;mappers&gt;&lt;mapper resource=&quot;mybatis映射文件路径(/)&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 批量123&lt;mappers&gt;&lt;package name=&quot;包名（.）&quot;/&gt;&lt;/mappers&gt; 只有遵守以下规范，才能实现批量加载映射 1、映射文件的命名。必须和接口名相同。比如:XxxDao/XxxDao.xml 2、必须和接口在同一个包下.比如:io.gitee.mysuperstart.dao XxxxMapper接口中方法参数有多个时，Mybatis如何进行取值？1、arg0、arg1 、… 2、param1、param2、… 3、@Param(“名称”)","link":"/2020/09/10/Mybatis%E8%BF%9B%E9%98%B6/"},{"title":"MySql常用语法","text":"DDL(数据库/表定义,操作数据库和表结构） 操作数据库创建数据库 create database 数据库名； 查看数据库的字符集 show create database 数据库名; 查看所有的数据库 show databases; 使用数据库 use 数据库名; 删除数据库 drop database 数据库名. 修改数据库字符集 alter database 数据名 character set 字符集; 操作数据表查看表结构/信息 desc 表名; show create table 表名; 查看当前数据库下的所有表 show tables; 查看表的字符集 show table status from 数据库 like “表名”; 创建表 create table 表名( ​ 字段/列名 数据类型 约束， ​ ….. ); 注意:每个字段间用”,”号分割，最后一个字段不需要 常用数据类型 类型 描述 double 类似java中的double int 类似java中的int date 格式:”yyyy-MM-dd” timestamp 时间戳。不给值或为null时采用系统日期时间。 datetime 格式:”yyyy-MM-dd HH:mm:ss” varchar(长度) 类似Java中的字符串,例:varchar(20) 修改表的字段类型 alter table 表名 modify 字段名 字段类型; 修改表名 alter table 旧表名 rename [to] 新表名; 修改表的字符集 alter table 表名 character set 字符集名称; 修改字段名和类型 alter table 表名 change 旧字段名 新字段名 数据类型 ; 添加字段(默认添加到末尾) alter table 表名 add 字段名 字段类型; 添加首字段 alter table 表名 add 字段名 字段类型 first; 在指定字段后添加新字段 alter table 表名 add 新字段名 新字段类型 after 指定字段; 删除字段 alter table 表名 drop 字段名; 删除表 drop table [if exists] 表名; DML(表记录增删改) 添加表数据添加全部列数据 insert into 表名 values(值1,……..); 添加指定列数据 insert into 表名(字段列表) values(值列表); 批量添加指定列数据 insert into 表名(字段列表) values(值列表)，(值列表)…; 批量添加全部列数据 insert into 表名 values(值列表),(值列表)…..; 修改&amp;删除表数据根据条件删除表数据 delete from 表名 where 条件; 根据条件更新表数据 update 表名 set 字段名 = 值1,字段名2 = 值2….. where 条件; 注意:一定要加条件进行修改和删除，否则表中的记录会整体受影响 DQL查询全部 select * from 表名; 查询指定列数据 select 字段列表 from 表名; 起别名查询 select 字段名 [ as] 别名 from 表名; ifnull函数查询 select ifnull(字段名,值) from 表名; 四则运算查询 select 操作数1 运算符 操作数2 from 表名 去重查询 select distinct 字段名 from 表名 条件查询 select ​ 字段列表 from ​ 表列表 where 条件 group by 字段 having 条件 limit 操作数 | 操作数,操作数 聚合函数 函数名 作用 sum() 求和 count() 统计次数 max() 最大值 min() 最小值 avg() 平均值 语法:select 函数名(字段) from 表名; 排序查询语法 select 字段列表 from 表名 order by 字段名 asc | desc; 分组查询语法 select 字段列表 from 表名 group by 字段名 having 条件 分页查询语法 select 字段列表 from 表名 limit 当前页数,查看的记录数; 当前 页数 = （要查看的页数-1）* 查看的记录数 约束 主键约束特点1、主键在一张表中只有一个 2、非空且唯一 添加建表时 create table 表名( ​ 列名 数据类型 primary key， ​ ……. ); 建表后 alter table 表名 modify 字段名 数据类型 primary key; 删除 alter table 表名 drop primary key; 主键自增约束特点通常都是给id设置自动增长，在添加数据的时候直接赋值为null或者default会自动赋值，自动增长的列只能是整数 添加建表时 create table 表名( ​ 字段名 字段类型 primary key auto_increment ​ …… ); 建表后 alter table 表名 modify 字段名 字段类型 auto_increment; 删除 alter table 表名 midfy 字段名 字段类型; 修改自动增长起始值 alter table 表名 auto_increment = 值; 唯一约束添加建表时 create table 表名( ​ 字段名 字段类型 unique, ​ ….. ); 建表后 alter table 表名 modify 字段名 数据类型 unique; 删除 alter table 表名 drop index 字段名; 非空约束添加建表时 create table 表名( ​ 字段名 数据类型 not null, ​ ……. ); 建表后 alter table 表名 modify 字段 字段类型 not null; 删除 alter table 表名 modify 字段 字段类型; 外键约束作用：建立了表与表之间的关联关系。保证了数据的准确性。 添加建表时 create table 表名( ​ 外键列名 外键列类型, ​ constraint 外键名 foreign key (本表外键列名) references 主表表名(主键) ); 建表后 alter table 表名 add constraint 外键名 foreign key(本表外键列名) references 主表表名(主键); 删除 alter table 表名 drop foreign key 外键名; 外键级联更新/删除 删除外键后级联也会随之删除 查看外键名称 show create table 表名; 添加级联更新 alter table 表名 add constraint 外键名 foreign key (本表外键列名) references 主表表名(主键) on update cascade; 添加级联删除 alter table 表名 add constraint 外键名 foreign key (本表外键列名) references 主表表名(主键) on delete cascade; 同时添加 alter table 表名 add constraint 外键名 foreign key (本表外键列名) references 主表表名(主键) on delete cascade on update cascade; 表关系一对一一对多建表原则多的一方添加外键列，建立外键约束，关联一的主键 例如：订单表和用户表、商品分类表和商品表等 多对多建表原则两张表间接建立了多对多的关系，需要创建第三张表，第三张表中关联另外两张表的id 例：用户表和商品表 创建表应该先创建主表，然后在接着创建从表 多表查询内连接查询查询的是两张表外键关联的交集数据 隐式内连接 select 字段列表 from 表1,表2 where 条件 显式内连接 select 字段列表 from 表1 inner join 表2 on/where 条件 外连接查询左外连接查询的是左表全部数据以及左右表的交集数据 select 字段列表 from 表1 left join 表2 on 条件 右外连接查询的是右表全部数据以及左右表的交集数据 select 字段列表 from 表1 right join 表2 on 条件 子查询结果是单行单列作为运算符的条件.比如&lt;、&lt;=、&gt;=、&gt; 、&lt;&gt;等 select 字段列表 from 表名 where 字段名 = (select 字段名 from 表名 [ where 条件]) [where 条件]; 结果是多行单列作为in || not in 的条件 select 字段列表 from 表名 where 字段名 not in (select 字段名 from 表名 [where 条件]) [where 条件]; 结果是多行多列 select 字段列表 from (select 字段列表 from 字段值 [where 条件]) as 别名 [where 条件]; 自关联查询自己查询自己。将自己进行拆分. 比如 ：员工和上级 select * from employee e1 ,employee e2 where e1.mgr = e2.id; 视图将一条较为复杂的查询语句的结果数据保存到视图中，下次还要使用到这个数据，直接查询视图即可，不用再次使用复杂的查询语句 创建视图 create view 视图名称 as 查询语句 ; 查询视图 select * from 视图名称; 修改视图数据 update 视图名称 set 字段名 = 字段值 ,…. where 条件; 修改视图结构命令 alter view 视图名称(字段列表) as 查询语句; 图形化界面 删除视图命令 drop view 视图名称； 图形化界面 注意:操作视图和操作表大同小异 备份和恢复数据库命令方式备份 恢复1、登录数据库 2、删除旧的数据库 3、创建新的数据库 4、使用数据库 5、使用source命令 6、查看是否成功 图形化界面方式备份 恢复1、先删除 2、再创建 3、运行SQL文件即可 存储过程=存储函数=Java中的方法创建1234567delimiter $create procedure 存储过程名([形参])begin -- 方法体 sql语句;end$delimiter ; 存储过程名命令规范:p_功能名 调用1、call 存储名([实参]) 2、call 存储名 3、call 存储名([select语句]) 删除1drop procedure 存储过程名; 查看12-- 查看数据库下面的所有的存储过程select * from mysql.proc where db=&quot;数据库名&quot;; 语法变量定义1declare 变量名 数据类型 [default 值]; 注意:变量只能定义在set之前，不能定义在set后面 1234-- 错误写法declare name varchar(20);set name = &quot;张三&quot;;declare age int; -- 变量只能定义在set语句前面，不能定义在这里 批量定义同类型变量12declare 变量名1,变量名2,变量名3... 数据类型-- 比如 :select address ,name varchar(20) 在Java中也是可以批量定义变量的，比如:String name,address; 赋值(3种方式)1、使用set关键字 1set 变量名 = 值; 2、定义变量并赋值 1declare 变量名 数据类型 default 默认值; 3、将select查询语句的结果赋值给变量 1select 字段名 into 变量名 from 表名 [where 条件]; 注意:mysql中没有扩展赋值运算符&amp;自增自减运算符 变量输出/使用12select 变量名列表;-- 比如 : select 变量名1,变量名2....; If语句单分支123if 条件1 then 条件1成立要执行的代码....end if; 多分支123456789if 条件1 then 条件1成立要执行的代码elseif 条件2 then 条件2成立要执行的代码.....else 以上条件都不成立要执行的代码-- 结束if语句end if; while语句123456初始化语句;while 循环条件 do 循环体代码... 步长/循环条件控制语句..(比如 set num = num + 1;)-- 结束while循环 end while; 建议：不管是if语句还是while语句，先搭建架子，后写逻辑代码 参数传递1、in ： 默认，表示输入参数，类似Java中方法的形参 示例: 12345-- 略...创建存储过程-- 声明p_demo(in name varchar(20))-- 调用call p_demo(&quot;张三&quot;); 2、out: 表示输出参数，可理解为Java中方法的返回值 示例: 123456-- 声明p_demo(out info varchar(20))-- 调用call p_Demo(@info) -- @info 就相当于一个会话变量，用来接收out类型的返回值-- 使用/输出select @info; 存储函数创建12345678delimiter $create function 函数名称([形参])returns 返回值类型begin sql语句; return 值;(值要和类型匹配)end$delimiter ; 函数名命名规范:f_功能名 调用1select 函数名称([实参列表]); -- 类似Java中的，System.out.println(getSum()); 删除1drop function 函数名; 存储过程和存储函数的区别？答：存储过程返回值可有可无，存储函数必须有返回值 Trigger触发器分类1、Insert型触发器 2、Update型触发器3、Delete型触发器 作用1、做数据校验 2、对表数据进行cru时进行日志记录 3、可模拟实现外键的级联删除和更新 创建123456789delimiter $create trigger 触发器名字before|after insert|update|deleteon 表名 -- 对该表名执行cru命令之前或者之后时，会自动触发下面的代码执行for each rowbegin 触发器要执行的代码end$delimiter ; 触发器命名规范：t_表名1__表名2 关键字/对象1、old :表示获取操作操作前/旧的数据,比如:old.id 2、new:表示获取操作后/新的数据,比如:new.name 注意：立场应该放在触发器要执行的代码&amp;执行表名相关代码的立场考虑 查看12-- 查看当前数据库下所有的触发器show triggers; 删除触发器1drop trigger 触发器名; 事务概念一条或多条sql语句组成的一个执行单元，要么同时成功，要么同时失败 特性(ACID)1、原子性:不可分割，要么同时成功，要么同时失败 2、隔离性 3、持久性 4、一致性 隔离级别1、读已提交 2、读未提交 3、可重复读（Mysql默认） 4、串行化 提交方式1、手动提交 2、自动提交（mysql默认） 查看提交方式1select @@AutoCommit; 修改提交方式1set @@Autocommit = 0 | 1; -- 0 表示手动提交 1 表示自动提交 常用操作1、开启事务 1start transaction; 2、提交事务 1commit; 3、回滚事务 1rollback; Mysql中常用函数1、now() :获取当前时间，年月日时分秒 2、curdate() ：获取日期, 年月日 3、concat() ： 用来拼接字符串，比如concat(a,b) ，结果ab,一定要注意拼接的格式 4、substring() ： 用来截取字符串 5、TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)计算两个时间差,还有datediff() 示例: select TIMESTAMPDIFF(year,19920202,CURDATE()) 6、ifnull(字段名,值) 如果字段名的值为null，就用后面的值代替，否则还是用字段名对应的值 7、database() 表示当前数据库 8、year(日期) 获取当前日期中的年，比如year(now())","link":"/2020/09/02/Mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"Mysql常用","slug":"Mysql常用","link":"/tags/Mysql%E5%B8%B8%E7%94%A8/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"Mysql","slug":"Mysql","link":"/categories/Mysql/"}]}